"use client"

import { useQuery, useMutation } from "convex/react"
import { api } from "@/convex/_generated/api"
import type { Id } from "@/convex/_generated/dataModel"
import type { UserMemory, CreateMemoryData, MemorySuggestion, RAGResult } from "@/types/memory"

export function useMemory() {
  // For now, we'll use a simple approach without projects since auth is disabled
  // In a full implementation, this would integrate with the projects system

  // Fetch memories for the current user and project
  const memoriesData = useQuery(api.memories.getMemoriesForUser, {
    onlyActive: true,
  })

  // Fetch memory analytics
  const analytics = useQuery(api.memories.getMemoryAnalytics)

  // Mutations
  const createMemoryMutation = useMutation(api.memories.createMemory)
  const updateMemoryMutation = useMutation(api.memories.updateMemory)
  const deleteMemoryMutation = useMutation(api.memories.deleteMemory)
  const trackUsageMutation = useMutation(api.memories.trackMemoryUsage)
  const createSuggestionMutation = useMutation(api.memories.createMemorySuggestion)
  const processSuggestionMutation = useMutation(api.memories.processSuggestion)

  // Transform Convex data to match the UserMemory interface
  const memories: UserMemory[] = (memoriesData || []).map((memory) => ({
    id: memory._id,
    userId: memory.userId,
    content: memory.content,
    title: memory.title,
    category: memory.category as UserMemory["category"],
    tags: memory.tags,
    createdAt: new Date(memory.createdAt),
    updatedAt: new Date(memory.updatedAt),
    isAutoGenerated: memory.category === "suggestion",
    priority: memory.priority,
    isActive: memory.isActive,
    lastUsedAt: memory.lastUsedAt ? new Date(memory.lastUsedAt) : undefined,
    usageCount: memory.usageCount,
  }))

  // For now, we'll return empty arrays for suggestions and RAG results
  // These will be implemented in future iterations
  const suggestions: MemorySuggestion[] = []
  const ragResults: RAGResult[] = []

  const createMemory = async (data: CreateMemoryData): Promise<UserMemory> => {
    const memoryId = await createMemoryMutation({
      title: data.title || data.content.substring(0, 50),
      content: data.content,
      category: data.category,
      tags: data.tags,
      isActive: true,
      priority: data.priority || 0,
      projectId: data.projectId as Id<"projects"> | undefined,
    })

    // Return a temporary memory object (the real one will come from the query)
    return {
      id: memoryId,
      userId: "temp",
      title: data.title,
      content: data.content,
      projectId: data.projectId,
      category: data.category,
      tags: data.tags,
      createdAt: new Date(),
      updatedAt: new Date(),
      isAutoGenerated: false,
      priority: data.priority,
      isActive: true,
    }
  }

  const updateMemory = async (id: string, updates: Partial<UserMemory>): Promise<void> => {
    await updateMemoryMutation({
      id: id as Id<"memories">,
      title: updates.title,
      content: updates.content,
      category: updates.category,
      tags: updates.tags,
      isActive: updates.isActive,
      priority: updates.priority,
    })
  }

  const deleteMemory = async (id: string): Promise<void> => {
    await deleteMemoryMutation({
      id: id as Id<"memories">,
    })
  }

  const acceptSuggestion = async (suggestionId: string): Promise<void> => {
    await processSuggestionMutation({
      suggestionId: suggestionId as Id<"memories">,
      accept: true,
    })
  }

  const dismissSuggestion = async (suggestionId: string): Promise<void> => {
    await processSuggestionMutation({
      suggestionId: suggestionId as Id<"memories">,
      accept: false,
    })
  }

  const searchMemories = async (query: string, projectId?: string): Promise<RAGResult[]> => {
    // This will be implemented with RAG in v2.0
    // For now, perform a simple client-side search
    const searchResults = memories.filter(
      (memory) =>
        memory.content.toLowerCase().includes(query.toLowerCase()) ||
        (memory.title && memory.title.toLowerCase().includes(query.toLowerCase()))
    )

    return searchResults.map((memory) => ({
      id: memory.id,
      content: memory.content,
      chatId: "unknown",
      timestamp: memory.createdAt,
      relevanceScore: 0.5,
      snippet: query,
    }))
  }

  const getMemoriesForContext = (projectId?: string): UserMemory[] => {
    // Memories are already filtered by project in the query
    return memories
  }

  const getMemoryStats = () => {
    if (!analytics) {
      return {
        total: 0,
        byCategory: {} as Record<string, number>,
        autoGenerated: 0,
        projectSpecific: 0,
        global: 0,
      }
    }

    return {
      total: analytics.totalMemories,
      byCategory: analytics.categoryCounts,
      autoGenerated: memories.filter((m) => m.isAutoGenerated).length,
      projectSpecific: memories.filter((m) => m.projectId).length,
      global: analytics.totalMemories - memories.filter((m) => m.projectId).length,
    }
  }

  const trackMemoryUsage = async (memoryId: string): Promise<void> => {
    await trackUsageMutation({
      memoryId: memoryId as Id<"memories">,
    })
  }

  return {
    memories,
    suggestions,
    ragResults,
    loading: memoriesData === undefined || analytics === undefined,
    createMemory,
    updateMemory,
    deleteMemory,
    acceptSuggestion,
    dismissSuggestion,
    searchMemories,
    getMemoriesForContext,
    getMemoryStats,
    trackMemoryUsage,
  }
}
