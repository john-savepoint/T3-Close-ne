"use client"

import { useState } from "react"
import type { UserMemory, CreateMemoryData, MemorySuggestion, RAGResult } from "@/types/memory"

// Mock data for demonstration
const mockMemories: UserMemory[] = [
  {
    id: "mem-1",
    userId: "user-1",
    content:
      "My preferred stack is the T3 Stack (Next.js, TypeScript, Tailwind, tRPC). All code examples should use this stack unless I specify otherwise. Use arrow functions for components and JSDoc for comments.",
    createdAt: new Date("2024-01-10"),
    updatedAt: new Date("2024-01-10"),
    isAutoGenerated: false,
    category: "preference",
  },
  {
    id: "mem-2",
    userId: "user-1",
    content: "My name is John Zealand-Doyle and I work as a full-stack developer at a startup.",
    createdAt: new Date("2024-01-12"),
    updatedAt: new Date("2024-01-12"),
    isAutoGenerated: false,
    category: "fact",
  },
  {
    id: "mem-3",
    userId: "user-1",
    projectId: "proj-1",
    content:
      "For this project, always use strict TypeScript with no 'any' types. Prefer functional components and custom hooks.",
    createdAt: new Date("2024-01-15"),
    updatedAt: new Date("2024-01-15"),
    isAutoGenerated: true,
    category: "instruction",
  },
  {
    id: "mem-4",
    userId: "user-1",
    projectId: "proj-3",
    content: "Target audience is Gen Z developers. Use emojis and a very informal tone.",
    createdAt: new Date("2024-01-18"),
    updatedAt: new Date("2024-01-18"),
    isAutoGenerated: false,
    category: "style",
  },
]

const mockSuggestions: MemorySuggestion[] = [
  {
    id: "sug-1",
    content: "You prefer to use JSDoc comments for function documentation",
    confidence: 0.85,
    context: "User consistently asks for JSDoc comments in code examples",
    dismissed: false,
  },
  {
    id: "sug-2",
    content: "You like to keep components under 100 lines of code",
    confidence: 0.72,
    context: "User mentioned preferring smaller, focused components",
    dismissed: false,
  },
]

const mockRAGResults: RAGResult[] = [
  {
    id: "rag-1",
    content:
      "We discussed Zustand as a lightweight state management library. You liked it because of its simple, hook-based API and minimal boilerplate compared to Redux.",
    chatId: "chat-5",
    timestamp: new Date("2024-01-05"),
    relevanceScore: 0.92,
    snippet: "What was that lightweight state management library we talked about for React?",
  },
  {
    id: "rag-2",
    content:
      "You mentioned using Framer Motion for animations in your last project and were happy with the performance.",
    chatId: "chat-8",
    timestamp: new Date("2024-01-08"),
    relevanceScore: 0.78,
    snippet: "animation library recommendations",
  },
]

export function useMemory() {
  const [memories, setMemories] = useState<UserMemory[]>(mockMemories)
  const [suggestions, setSuggestions] = useState<MemorySuggestion[]>(mockSuggestions)
  const [ragResults, setRagResults] = useState<RAGResult[]>(mockRAGResults)
  const [loading, setLoading] = useState(false)

  const createMemory = async (data: CreateMemoryData): Promise<UserMemory> => {
    setLoading(true)

    // Simulate API call
    await new Promise((resolve) => setTimeout(resolve, 500))

    const newMemory: UserMemory = {
      id: `mem-${Date.now()}`,
      userId: "user-1",
      content: data.content,
      projectId: data.projectId,
      category: data.category || "preference",
      createdAt: new Date(),
      updatedAt: new Date(),
      isAutoGenerated: false,
    }

    setMemories((prev) => [...prev, newMemory])
    setLoading(false)

    return newMemory
  }

  const updateMemory = async (id: string, updates: Partial<UserMemory>): Promise<void> => {
    setLoading(true)

    // Simulate API call
    await new Promise((resolve) => setTimeout(resolve, 300))

    setMemories((prev) =>
      prev.map((m) => (m.id === id ? { ...m, ...updates, updatedAt: new Date() } : m))
    )

    setLoading(false)
  }

  const deleteMemory = async (id: string): Promise<void> => {
    setLoading(true)

    // Simulate API call
    await new Promise((resolve) => setTimeout(resolve, 300))

    setMemories((prev) => prev.filter((m) => m.id !== id))

    setLoading(false)
  }

  const acceptSuggestion = async (suggestionId: string): Promise<void> => {
    const suggestion = suggestions.find((s) => s.id === suggestionId)
    if (!suggestion) return

    // Create memory from suggestion
    await createMemory({
      content: suggestion.content,
      category: "preference",
    })

    // Remove suggestion
    setSuggestions((prev) => prev.filter((s) => s.id !== suggestionId))
  }

  const dismissSuggestion = async (suggestionId: string): Promise<void> => {
    setSuggestions((prev) =>
      prev.map((s) => (s.id === suggestionId ? { ...s, dismissed: true } : s))
    )
  }

  const searchMemories = async (query: string, projectId?: string): Promise<RAGResult[]> => {
    setLoading(true)

    // Simulate RAG search
    await new Promise((resolve) => setTimeout(resolve, 800))

    // Filter mock results based on query relevance
    const filteredResults = ragResults.filter(
      (result) =>
        result.content.toLowerCase().includes(query.toLowerCase()) ||
        result.snippet.toLowerCase().includes(query.toLowerCase())
    )

    setLoading(false)
    return filteredResults
  }

  const getMemoriesForContext = (projectId?: string): UserMemory[] => {
    return memories.filter((memory) => !memory.projectId || memory.projectId === projectId)
  }

  const getMemoryStats = () => {
    const total = memories.length
    const byCategory = memories.reduce(
      (acc, memory) => {
        const category = memory.category || "other"
        acc[category] = (acc[category] || 0) + 1
        return acc
      },
      {} as Record<string, number>
    )
    const autoGenerated = memories.filter((m) => m.isAutoGenerated).length
    const projectSpecific = memories.filter((m) => m.projectId).length

    return {
      total,
      byCategory,
      autoGenerated,
      projectSpecific,
      global: total - projectSpecific,
    }
  }

  return {
    memories,
    suggestions: suggestions.filter((s) => !s.dismissed),
    ragResults,
    loading,
    createMemory,
    updateMemory,
    deleteMemory,
    acceptSuggestion,
    dismissSuggestion,
    searchMemories,
    getMemoriesForContext,
    getMemoryStats,
  }
}
